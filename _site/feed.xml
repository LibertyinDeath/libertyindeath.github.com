<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LibertyinDeath</title>
    <description>For the brave souls who get this far:  You are the chosen ones,the valiant knights of programming who toil away, without rest, fixing our most awful code.  To you, true saviors, kings of men,I say this: never gonna give you up, never gonna let you down,never gonna run around and desert you.  Never gonna make you cry,never gonna say goodbye. Never gonna tell a lie and hurt you.
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 30 Dec 2016 15:17:58 +0800</pubDate>
    <lastBuildDate>Fri, 30 Dec 2016 15:17:58 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>比特币到底是什么</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;比特币是什么？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;比特币是一种电子货币体系&lt;/li&gt;
  &lt;li&gt;从操作形式上，你可以将其理解为类似Q币，你看不到摸不着，但是它是有价值的&lt;/li&gt;
  &lt;li&gt;与Q币不同的是，Q币是腾讯公司提供的虚拟货币，随意就可以创造出来，比特币必须通过特殊的手段（挖矿）才能产生，而且其有创造的规则（共2100万枚，每十分钟产生一个）&lt;/li&gt;
  &lt;li&gt;用一种比较准确的描述：比特币是一种由开源的P2P软件产生的数字货币，是通过计算产生的，&lt;strong&gt;由一串复杂的计算机代码组成&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;比特币没有特定的中央发行机构，而是使用遍布整个P2P网络节点的分布式数据库来记录货币的交易，并使用密码学的密码设计来确保货币流通各个环节的安全性&lt;/li&gt;
  &lt;li&gt;简单的说，比特币就是一种无发行机构（政府、企业、个人等），通过一种特殊计算方法（你只需要知道名字叫哈希就行了），自然生成于互联网，具有实际价值，并被全球公认的电子货币&lt;/li&gt;
  &lt;li&gt;这里的全球公认指的是，任何人都可以参与货币制造，而且可以全世界流通，可以在任意一台接入互联网的计算机上买卖。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;比特币为什么能成为货币&lt;/h3&gt;

&lt;p&gt;很多人都会有这样的疑问，这种网络上的东西，怎么就会莫名奇妙有了价值，并成了投资的对象？&lt;/p&gt;
&lt;p&gt;那我这么问一句，黄金的价值在哪里？为什么这么多人去买？去收藏？并且黄金成了最保值的东西？有人想过这个问题吗？&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;黄金是怎么成为货币的&lt;/h4&gt;
&lt;p&gt;这个问题等价于“黄金为什么天然是货币”。&lt;/p&gt;
&lt;p&gt;从以物易物、从贝壳再到铜币、金银充当货币以至铸造金币银币，再到纸币、电子货币等，这是一个随着经济发展的货币的发育史过程。&lt;/p&gt;
&lt;p&gt;黄金一开始不是货币，只是商品，因其是贵金属、稀少、耐腐蚀、耐高温（早有真金不怕火炼一说）、不坚硬易分割、不生诱等原因，更易充当价值尺度、交换媒介和保值手段等，被各国殊途同归地当成货币使用。这是一个市场自然选择的结果。&lt;/p&gt;
&lt;p&gt;最初的金币，在其标明价值时，与其本身的重量所值是一致的。我国历史上是否铸造过金币，我不清楚，但银元是有过的。黄金、银子、银元与铜币一起，均可作为货币使用。这些金属或金属币，本身就有其价值含量。&lt;/p&gt;
&lt;p&gt;由于黄金稀少，由于金属沉重，越来越不能满足流通的需要，于是有了纸币，纸币既是政府信用，因为政府才有铸币权，同时也以黄金储备为其担保。&lt;/p&gt;
&lt;p&gt;政府的信用并不是绝对可靠的，而黄金因其稀少，具有绝对可靠性，在国与国之间有经济往来时，货币的信用要以黄金的储备来担保，货币量要与黄金的储备量一致，纸币只是黄金的标志物。这就是金本位制。&lt;/p&gt;
&lt;p&gt;在国际间，美元曾经是与黄金挂钩的货币，即其他国家可用美元去兑换美国的等量黄金。１９７１年，由于美元爆发危机，尼克松宣布停止履行外国可用美元向美国兑换黄金的义务，美元从此与黄金脱钩。&lt;/p&gt;
&lt;p&gt;现在情况是，货币不再实行金本位制或银本位制，货币只剩下了信用关系，以政府的信用、社会的稳定为担保。当这种信用担保关系存在，所有的人都认为这个货币可以作为等价物换回等量的商品时，币值就稳定。一个好处是，由于科技发展，货币可以不受黄金储备制约，获得更多的表现形式，更好地满足经济发展的需要，例如电子货币，瞬间可以在国际间往来，分流，快捷地组织经济活动。但由于不再以黄金储备为担保，如政府当局为自己解困或因某种原因超量发行了货币，货币就贬值，信用关系就受到了破坏。在这个时候，黄金的价格就上升。&lt;/p&gt;
&lt;p&gt;而黄金作为稀有金属，本身是有价值的价值的，一串计算机代码为什么会跟黄金一样成为货币呢&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;比特币的价值在哪里&lt;/h4&gt;

&lt;p&gt; 比特币具有价值是因为比特币具有货币的数学特性(持久性，可携带性，可互换性，稀缺性，可分割性和易识别性)而非依赖于物理特性(比如黄金和白银)或中央权力机构的信任(比如法定货币)。简而言之，比特币是由数学支持的。有了这些特性，一种货币形式要具有价值所需要的就是信任和使用。对比特币而言，这可以从它日益增长的用户，商家和初创企业基数上得到体现。同所有货币一样，比特币的价值直接来自于愿意接受它作为支付方式的人们，这也是唯一的来源。而一旦比特币不再流通，其也就失去了价值，成为真正的一串代码，毫无用处&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;比特币哪里来的&lt;/h3&gt;

&lt;p&gt;终于讲到这个问题了，本来是想把这个放到第一个讲，但是想了下从哪里来还是没有是什么重要&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;谁创造了比特币&lt;/h4&gt;
&lt;p&gt;比特币是第一个实现了“隐秘货币”概念的货币。1998年，Wei Dai在cypherpunks邮件列表中首次阐述了“隐秘货币”的概念，即：一个采用密码学原理控制货币的发行和交易、而不是依赖于中央管理机构的全新的货币形态。2009年，中本聪（Satoshi Nakamoto 化名）在cryptography邮件列表中发表了第一个比特币规范及其概念证明。2010年年底，中本聪离开该项目，关于他的身份没有透露太多。此后，众多开发人员致力于比特币的项目，比特币社区迅速成长起来。&lt;/p&gt;
&lt;p&gt;中本聪的匿名身份经常会引起毫无根据的忧虑，其中很多是与比特币开放源代码特性的误解有关。比特币的协议和软件都是公开发布的，世界各地的任何开发人员都可以查看其代码，或者开发他们自己修改过的比特币软件版本。就像目前的开发人员，中本聪的影响仅仅局限于那些他做出的被其他人采纳的改动，因此，中本聪并没有控制比特币。那么，在今天，关于比特币的发明者的身份问题可能和纸张发明者的身份问题一样。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;有人控制比特币吗？是谁？&lt;/h4&gt;
&lt;p&gt;最开始的时候，我对这个问题非常困惑，难道这个东西是凭空产生的吗？总要有一个操控者才好啊&lt;/p&gt;
&lt;p&gt;没有谁拥有比特币网络，就像没有人拥有电子邮件背后的技术一样。比特币由世界各地所有的比特币用户控制。开发者可以改善软件，但他们不能强行改变比特币协议的规则，因为所有的用户都可以自由选择他们想用的软件。为了相互之间保持兼容性，所有用户也需要选择遵循相同规则的软件。只有所有用户达成完全一致的共识，比特币才能正常地工作。因此，所有的用户和开发者对接受和保护这一共识很有动力。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;比特币是如何运作的&lt;/h4&gt;

&lt;p&gt;从用户的角度来看，比特币就是一个手机应用或电脑程序，可以提供一个个人比特币钱包，用户可以用它支付和接收比特币。这就是比特币对于大多数用户的运作原理。&lt;/p&gt;

&lt;p&gt;在幕后，整个比特币网络共享一个称作“块链”的公共总帐。这份总帐包含了每一笔处理过的交易，使得用户的电脑可以核实每一笔交易的有效性。每一笔交易的真实性由发送地址对应的电子签名保护，这使得用户能够完全掌控从他们自己的比特币地址转出的比特币。另外，任何人都可以利用专门硬件的计算能力来处理交易并为此获得比特币奖励。这一服务经常被称作“挖矿”。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;什么是挖矿&lt;/h4&gt;

&lt;p&gt;挖矿是消耗计算资源来处理交易，确保网络安全以及保持网络中每个人的信息同步的过程。它可以理解为是比特币的数据中心，区别在于其完全去中心化的设计，矿工在世界各国进行操作，没有人可以对网络具有控制权。这个过程因为同淘金类似而被称为“挖矿”，因为它也是一种用于发行新比特币的临时机制。然而，与淘金不同的是，比特币挖矿对那些确保安全支付网络运行的服务提供奖励。在最后一个比特币发行之后，挖矿仍然是必须的。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;比特币的挖矿的原理是什么？&lt;/h4&gt;

&lt;p&gt;任何人均可以在专门的硬件上运行软件而成为比特币矿工。挖矿软件通过P2P网络监听交易广播，执行恰当的任务以处理并确认这些交易。比特币矿工完成这些工作能赚取用户支付的用于加速交易处理的交易手续费以及按固定公式增发的比特币。&lt;/p&gt;
&lt;p&gt;新的交易需要被包含在一个具有数学工作量证明的区块中才能被确认。这种证明很难生成因为它只能通过每秒尝试数十亿次的计 算来产生。矿工们需要在他们的区块被接受并拿到奖励前运行这些计算。随着更多的人开始挖矿，寻找有效区块的难度就会由网络自动增加以确保找到区块的平均时间保持在10分钟。因此，挖矿的竞争非常激烈，没有一个个体矿工能够控制块链里所包含的内容。&lt;/p&gt;
&lt;p&gt;挖矿算法的最终呈现形式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHA256(SHA256(version+prev_hash+merkle_root+ntime+nbits+x))&amp;lt;TARGET
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除ｘ外，这里的其余值都是已知的，只需要找出满足条件的ｘ就可以，而寻找的方式对计算机来说是一个一个试，所以说挖矿对计算机的性能要求很高&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- version:Block的版本
- prev_bash:上一个Block的hash值
- merkle_oot:需要写入的交易记录的ｈａｓｈ树的值
- ntime:更新时间
- x:运算结果的唯一参数，范围在０～2^32
- nbits:当前运算难度，最终反映结果为TARGET,即所获得的奖励
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;特别要说明的是，此处的交易记录不只是一条交易记录的数据，而是这个Block中包含的所有交易记录，即过去十分钟的交易记录&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;什么是矿池&lt;/h4&gt;

&lt;p&gt;比特币矿池是一个组队挖矿的服务器，比特币每１０分钟产生一个Block，会有几千万人去竞争，而这个Block最终只能归一个人，其余人全部颗粒无收&lt;/p&gt;
&lt;p&gt;组队挖矿就是大家利用自己的矿机或挖矿终端，进入同一个服务器，让加入进来的各个节点的计算能力汇集在一起，一旦队伍里面有人获得了Block,就按照大家提供的算力（即设备的性能）分发比特币&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;扩展问题&lt;/h3&gt;

&lt;h4 id=&quot;section-12&quot;&gt;比特币会变得不值钱吗？&lt;/h4&gt;

&lt;p&gt;可能会。历史上有很多不成功而不再使用的货币，比如魏玛共和国时期的 德国马克以及更近的 津巴布韦元。虽然以前的货币失败通常是由于在比特币上不可能发生的超通货膨胀，但是总会有潜在的技术失误，竞争货币和政治问题等。基本的经验就是，没有一种货币可以被认为是绝对安全，不会出现失败或困难时期的。比特币自诞生起几年中被证明是可靠的，而且比特币继续成长的潜力很大。但是，没有人能够预测比特币的未来会怎样。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;比特币是泡沫吗？&lt;/h4&gt;

&lt;p&gt;价格的快速上涨并不会构成泡沫。人为的高估将会导致一个突然向下的修正，才会构成泡沫。基于成千上万的市场参与者个体行为的选择导致比特币价格的波动是市场决定价格的结果。从情感上说，价格变动的原因包括：对比特币失去信心，不是基于比特币经济的基本面的价格和价值之间的巨大差异，越来越多的刺激投机性需求的新闻报道，对不确定性的恐惧，以及过时的非理性的繁荣和贪婪。&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;比特币是庞氏骗局吗？&lt;/h4&gt;

&lt;p&gt;庞氏骗局是一种诈骗性的投资运作，它是利用投资者自己的钱作为回报支付给投资者，或者利用新投资人的钱支付给老投资者，而非通过公司本身经营所赚的钱作为回报。当没有足够的新投资人加入便导致庞氏骗局瓦解，最后的投资人便会蒙受损失。&lt;/p&gt;
&lt;p&gt;比特币是一个无中央管理机构的自由软件项目，因此，没有人能够对投资回报做虚假的陈述。就像其他主要货币，如黄金、美元、欧元、日元等，比特币不能保证购买力并且汇率是自由浮动的。由此导致的波动性使得比特币持有者无法预测获利或损失。事实是，由于其有用的和有竞争力的特性，比特币正在为成千上万的用户和企业所使用。&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;越早接触比特币的人获利更多吗&lt;/h4&gt;

&lt;p&gt;一些早期使用者拥有大量的比特币，因为他们在一个未经证实的技术上冒着风险投入了时间和资源，而当时该技术几乎还无人使用，也更难保证其安全性。在比特币变得有价值之前，许多早期的使用者经常消费大量的比特币，或者仅仅只买了少量的比特币，因此并没有获得巨大的收益。谁也不能保证比特币的价格将上涨或下跌。这非常像投资给一个早期的初创公司，可能会随着其实用性和普及获得价值，也也可能一直没有突破。比特币尚处于起步阶段，它的设计者眼光长远；很难想象它如何能够更少地偏向早期的使用者，今天的用户可能会是明天的早期使用者，也可能不是。&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;比特币的总量有限不会有局限性吗？以后发展怎么办&lt;/h4&gt;

&lt;p&gt;Bitcoin 的独特之处在于只有总量为2100万的比特币会被生成。但是这根本不会成为一种局限，因为交易中可以将比特币划分成更小的次级单位，比如 bit - 一比特币等于 1,000,000 bit。一个比特币可以拆分到小数点后8位 （0.000 000 01），如果将来平均单笔交易规模减小到一定程度时，甚至可以拆分到更小的单位。&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Dec 2016 13:11:38 +0800</pubDate>
        <link>http://yourdomain.com/the_internet/2016/12/30/bitcoin.html</link>
        <guid isPermaLink="true">http://yourdomain.com/the_internet/2016/12/30/bitcoin.html</guid>
        
        
        <category>The_internet</category>
        
      </item>
    
      <item>
        <title>翻墙那些事</title>
        <description>&lt;h3 id=&quot;vpn&quot;&gt;vpn是什么&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Virtual Private Network(虚拟专用网络),指在公用网络上建立专用网络&lt;/li&gt;
  &lt;li&gt;公用网络上传输的数据，存在着安全隐患。 公共网络上传输的数据，如果没有采取加密之类的措施的话，有可能被黑客们嗅探到，这就会导致信息泄漏，比如帐号密码、企业资料等，就会造成造成损失。&lt;/li&gt;
  &lt;li&gt;为了避免信息在网络传输中被人嗅探到，最好的方式就是架设一条私人网络线路，这个私人线路只有得到授权的人才能使用，这样就大大减少了数据被他人窃取的风险。但是如果距离很远，那么建设私人网络线路的成本就太高了。比如美国某公司在中国的分公司和其美国总公司之间网络通讯，为此专门建立一条线路，其成本之高可想而知了。
    - vpn不需要架设专门的物理线路，而是利用现有的公用网络线路，通过隧道技术、加解密技术、秘钥管理技术、身份认证技术等方式，建立出一条安全的网络连接，没有得到身份验证的人，是无法进入的。这等同于专门架设了一条私有线路。这条线路是通过技术虚拟出来的，是一条临时的线路，只要连接双方断开连接，该线路就会消失，因此称之为虚拟专用网络
    &lt;ul&gt;
      &lt;li&gt;目前网络上常见的vpn，主要有PPTP、L2TP、L2TP/IPsec、SSL VPN、Cisco VPN、OpenVPN 等类型。其中 PPTP、L2TP 两种方式，传输的数据是没有加密的，对于安全性较高的用户而言，不要选这两种方式。其他几种则都有数据加密，安全性更高。&lt;/li&gt;
      &lt;li&gt;最初vpn的作用是，很多商业公司，为了让那些不在公司里的员工（比如出差在外的）能够方便地访问公司的内部网络。为了防止黑客冒充公司的员工，从外部访问公司的内部网络，VPN 软件都会提供强大的加密功能。而这个加密功能，也就让它顺便成为翻墙的利器。&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;就好比不通过快递员，你亲自把包裹交给收件人所在公司的前台，再由前台转交给收件人&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proxy&quot;&gt;&lt;strong&gt;proxy是什么&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。&lt;/li&gt;
  &lt;li&gt;提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。&lt;/li&gt;
  &lt;li&gt;一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存了的资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。代理服务器的选项和设置在计算机程序中，通常包括一个“防火墙”，允许用户输入代理地址，它会遮盖他们的网络活动，可以允许绕过互联网过滤实现网络访问。
    - &lt;em&gt;可以看作是一个快递员，负责将你的包裹送达收件人。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ssh&quot;&gt;ssh是什么&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。&lt;/li&gt;
  &lt;li&gt;简单说，SSH是一种网络协议，用于计算机之间的加密登录。&lt;/li&gt;
  &lt;li&gt;如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。&lt;/li&gt;
  &lt;li&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。
    - &lt;em&gt;就好比把包裹装在保险箱里面再交给快递员。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vpn-1&quot;&gt;如何使用vpn翻墙&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用 VPN 通常需要先安装客户端软件。当你运行 VPN 客户端，它会尝试联到 VPN 服务器（这点跟加密代理类似）。一旦和 VPN 服务器建立连接，VPN 客户端就会在你的系统中建立了一个虚拟局域网。而且，你的系统中也会多出一个虚拟网卡（在 Windows 下，可以用 ipconfig /all 命令，看到这多出来的网卡）。这样一来，你的系统中就有不止一块网卡。这就引出一个问题：那些访问网络的程序，它的数据流应该通过哪个网卡进出？&lt;/li&gt;
  &lt;li&gt;为了解决此问题，VPN 客户端通常会修改你系统的路由表，让那些数据流，优先从虚拟的网卡进出。由于虚拟的网卡是通往 VPN 服务器的，当数据流到达 VPN 服务器之后，VPN 服务器再帮你把数据流转向到真正的目的地。&lt;/li&gt;
  &lt;li&gt;　　前面说了，VPN 为了保证安全，都采用强加密的方式传输数据。这样一来，GFW 就无法分析你的网络数据流，进行敏感词过滤。所以，使用墙外的VPN服务器，无形中就能达到翻墙的效果。
    - 首先，你要下载一个hss的下载器，这个要翻墙才能下载，所以我放在了百度云里面，https://pan.baidu.com/s/1sk86LnZ
    &lt;ul&gt;
      &lt;li&gt;安装方法非常傻瓜，不多赘述&lt;/li&gt;
      &lt;li&gt;安装好之后，到开始菜单里面，点击“Hotspot Shield Launch”，就启动了 HSS。启动之后，系统托盘会出现一个 HSS 的图标。如果能正常连接到 VPN 服务器，该图标会变为绿色。之后，你就可以尽情享受翻墙带来的乐趣。&lt;/li&gt;
      &lt;li&gt;前面说了，一旦 VPN 装好，所有软件无需额外设置，都能够翻墙了。但是，这也引来新的问题。有些网友比较看重性能：希望能够不经过 VPN，直接访问国内的网站；只有国外的网站才走 VPN。这时候，前面提到的“路由表”就排上用场了。&lt;/li&gt;
      &lt;li&gt;如果你没有 IT 技术背景，听到“路由表”这么高深的词汇，估计心里发虚。不过没关系，天朝不乏热心的网友，已经帮大伙儿做好了傻瓜化的工具。不需要对路由表有深入的理解，便可搞定。
        &lt;ol&gt;
          &lt;li&gt;首先，向大伙儿隆重介绍 chnroutes 开源项目（网站在“这里”）。该项目提供了预先定制好的路由表，能够做到国内网站自联，国外网站走VPN&lt;/li&gt;
          &lt;li&gt;到该网站的“这里”，下载一个压缩包（名为 pre_created_for_win.zip）。只有8.5K，一眨眼就下载完。&lt;/li&gt;
          &lt;li&gt;把压缩包解开，里面有4个文件，咱们只需要俩（vpnup.bat 和 vpndown.bat）。&lt;/li&gt;
          &lt;li&gt;当你需要调整路由的时候，（以管理员身份）双击 vpnup.bat&lt;/li&gt;
          &lt;li&gt;当你需要把路由表复原的时候，就（以管理员身份）双击 vpndown.bat
            &lt;ul&gt;
              &lt;li&gt;（运行上述俩脚本，大约需要几分钟，快慢与否取决于你电脑的性能）&lt;/li&gt;
              &lt;li&gt;怎么样？是不是很简单？懂技术的网友，可以用 tracert 命令来验证路由表修改后的路由效果。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;proxy-1&quot;&gt;如何使用proxy翻墙&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;代理服务器主要有两种类型&lt;/li&gt;
  &lt;li&gt;HTTP代理：最简单的一种代理形式，能够代理客户机的HTTP访问，上网浏览网页使用的都是HTTP协议，通常的HTTP代理端口为80、3128或8080端口。&lt;/li&gt;
  &lt;li&gt;SOCKS代理：SOCKS代理与HTTP等其他类型的代理不同，它只是简单地传递数据包，而并不关心是何种应用协议，既可以是HTTP协议，也可以是FTP协议，或者其他任何协议，所以SOCKS代理服务器比其他类型的代理服务器速度要快得多。SOCKS代理又分为SOCKS4和 SOCKS5，二者不同的是SOCKS4代理只支持TCP协议（即传输控制协议），而SOCKS5代理则既支持TCP协议又支持UDP协议（即用户数据包协议），还支持各种身份验证机制、服务器端远程域名解析（解决DNS污染就靠这个了）等。SOCK4能做到的SOCKS5都可得到，但SOCKS5能够做到的SOCKS则不一定能做到。&lt;/li&gt;
  &lt;li&gt;目前SOCKS5是最常用的一种SOCKS代理。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;下载shadowsocks客户端&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Windows：https://pan.baidu.com/s/1jHY3zWq&lt;/li&gt;
          &lt;li&gt;Linux：   https://pan.baidu.com/s/1jHOuiN0&lt;/li&gt;
          &lt;li&gt;Mac：https://github.com/shadowsocks/shadowsocks-iOS/releases/download/2.6.3/ShadowsocksX-2.6.3.dmg&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;去买账号&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;个人推荐使用付费版本，当然只是为了尝鲜翻个墙玩一玩就算了，直接用免费的也可以，这个地址会定期发布一些账号，不保证稳定https://www.dou-bi.co/sszhfx/&lt;/li&gt;
          &lt;li&gt;付费版直接去www.shadowsocks.com，这个跟shadowsocks客户端没有半毛钱关系，我只是之前用过，免费给人家打广告。&lt;/li&gt;
          &lt;li&gt;具体配置自己搞&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;也可以直接使用国人开发的lantern进行翻墙，稳定性以及流量都比较中肯，记住别浏览视频哦
    &lt;ul&gt;
      &lt;li&gt;Windows： https://pan.baidu.com/s/1o811B4Y&lt;/li&gt;
      &lt;li&gt;Mac：     https://pan.baidu.com/s/1dFMIDmL&lt;/li&gt;
      &lt;li&gt;Ubuntu：  https://pan.baidu.com/s/1pLCoRjH&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Dec 2016 12:22:38 +0800</pubDate>
        <link>http://yourdomain.com/computer_basis_knowledge/2016/12/28/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://yourdomain.com/computer_basis_knowledge/2016/12/28/welcome-to-jekyll.html</guid>
        
        
        <category>computer_basis_knowledge</category>
        
      </item>
    
      <item>
        <title>计算机是怎么“上网”的</title>
        <description>&lt;h3 id=&quot;www&quot;&gt;什么是www&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先，我们都知道我们生活在网络里，即万维网（www，World Wide Web）；&lt;/li&gt;
  &lt;li&gt;www是一张遍布全球的计算机网络；&lt;/li&gt;
  &lt;li&gt;web中的所有计算机均可彼此相互通信；&lt;/li&gt;
  &lt;li&gt;所有的计算机都使用被称为HTTP的通信标准；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;www-1&quot;&gt;www如何工作&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web 信息存储于被称为网页的文档中。&lt;/li&gt;
  &lt;li&gt;网页是存储于名为 web 服务器的计算机中的文件。&lt;/li&gt;
  &lt;li&gt;读取网页的计算机可称为 web 客户机。&lt;/li&gt;
  &lt;li&gt;web 客户机通过名为 web 浏览器的程序来查看页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;浏览器是如何加载的&lt;/h3&gt;
&lt;p&gt;当你浏览网页时的情况基本上是这样的：你坐在你的电脑前，并希望看到在网络上某台计算机上的一个文档，而你有这个文档的URL,也就是我们敲在地址栏里面的那个链接,但仅仅这样还是不够的&lt;/p&gt;
&lt;p&gt;如果你想要读取那个文件，存储这个文件的计算机必须运行一个web服务器程序，一个web服务器是一个监听来自浏览器的请求，然后执行他们的计算机程序。&lt;/p&gt;
&lt;p&gt;也就是说，浏览器与服务器联系并请求服务器传送文件给它，服务器响应并发送文件，浏览器根据文件的类型进行显示&lt;/p&gt;
&lt;p&gt;浏览器会直接显示HTML文档，如果HTML文档它包含指向图像，Java小程序，声音剪辑等的内容，浏览器也会从它们所在的服务器请求这些文件(图像，Java小程序，声音剪辑等,这些文件通常在同一台服务器，但并不总是)。值得一提的是，这将是单独的请求，并给服务器和网络添加额外的负载。当用户点击另一个连接的时整个序列就又重新开始了。&lt;/p&gt;
&lt;p&gt;这些响应和请求必须是双方能够理解的，就像你说“hello”，“对方就不能说”你好“，所以制定了一个叫HTTP（超文本传输）协议的东西，但是HTTP协议只定义了双方说的内容是什么，并没有说具体的怎么把这些东西传输出去。就好像我们用中文，但是我们用嘴说还是用笔写，还是打字，这是另一种东西，跨越网络传输比特和字节的实际工作是由 TCP和IP协议实现的，也就是说TCP/IP定义具体怎么把内容传输给对方，大多数其他互联网协议如(FTP,Gopher)也是依赖于TCP/IP实现传输的。&lt;/p&gt;
&lt;p&gt;首先要解释两个概念，客户端是指任何做网页浏览器一样工作的软件程序（比如app）；服务器是指服务器程序，而不是运行服务器软件的计算机&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;当我点击一个链接，会发生什么？&lt;/h3&gt;

&lt;h4 id=&quot;url&quot;&gt;第一步，解析url&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，浏览器所要做的就是要查看新文档的URL，看如何取得这个文档。大多数URL有这样的基本形式：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URI&lt;/span&gt;      &lt;span class=&quot;err&quot;&gt;协议&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;服务器&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;请求的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;URI&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libertyindeath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;html&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;protocol : 告诉浏览器如何检索服务器；&lt;/li&gt;
  &lt;li&gt;server : 告诉浏览器服务器的地址，就是告诉了浏览器去哪里连接服务器；&lt;/li&gt;
  &lt;li&gt;request-URI : 是Web服务器用来确定该文件的名称。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;第二步，发送请求&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常，协议是“http”的。通过HTTP检索文档的浏览器发送以下请求到服务器：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /request-URI HTTP/version
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;version是说用的http哪个版本，不能繁体字跟简体字混用&lt;/li&gt;
  &lt;li&gt;这里很重要的一点是，这个请求字符串是服务器看到的所有东西。因此服务器并不关心，请求是来自一个浏览器、一个链接检查程序、搜索引擎爬虫或者是你在手动键入这个请求字符串。服务器只是执行请求，并返回结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;第三步，服务器响应&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当服务器接收到HTTP请求，并找到适当的文档就返回它。然而，HTTP响应被要求具有特定的形式。它必须看起来像这样：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/[VER] [CODE] [TEXT]
Field1: Value1
Field2: Value2

...Document content here...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;第一行显示了所使用的HTTP版本，随后是3位数字（HTTP状态代码）和可以给人看的对应于状态码的短语。通常情况下[code] 和[TEXT]为200 OK,这意味着一切运行良好。第一行后面跟着一些所谓的header，包含关于文档的信息。用一个空行结束header，然后后面就跟着文档的内容。下面是一个典型的header：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.0 200 OK
Server: Netscape-Communications/1.1
Date: Tuesday, 25-Nov-97 01:22:04 GMT
Last-modified: Thursday, 20-Nov-97 10:44:53 GMT
Content-length: 6372
Content-type: text/html

&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&amp;gt;
&amp;lt;HTML&amp;gt;
...followed by document content...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们从这个响应头可以的第一行看到，请求成功了。第二行是可选的，并且告诉我们，在服务器运行的Web服务器是Netscape-Communications，1.1版。然后，我们得到了什么服务器当前的日期和文件的最后修改时间，然后是文件的字节大小，最后，最重要的字段是：Content-type。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内容类型(Content-type)字段被浏览器用来判断接收到的文件格式，HTML文件格式是被定义为text/html，text/plain为普通文本，GIF是image/gif等。这样做的优点是，该URL可以具有任意的结尾而浏览器将仍然能得到文档的正确格式并正确解析。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这里有一个重要的概念是，对于浏览器，服务器可以作为一个黑盒子。即：浏览器请求一个特定的文件，服务器要么是正确返回文件或者返回一个错误消息。服务器如何产生文档对浏览器来说仍然是未知的。这意味着服务器程序可以从一个文件中读取、运行一个程序生成，通过分析一些命令配置编译等种种方式生成这个文档。这使服务器管理员有很大的自由尝试各种不同的服务，因为用户不关心（甚至不知道）他看的的页面是如何生成的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;服务器干嘛的&lt;/h3&gt;
&lt;p&gt;当服务器被配置好的时候，它通常被配置到磁盘上的某个地方使用一个目录作为其根目录，并且每个目录会有一个默认的文件名（例如index.html）。这意味着，如果你向服务器请求文件“/”（如http://www.domain.tld/），你会获得在服务器根目录下的index.html文件。通常情况下，请求/foo/bar.html，服务器会给你服务器根目录下的foo的目录中的bar.html文件。&lt;/p&gt;
&lt;p&gt; 通常情况下是这样的。但是也可以将服务器的/foo/映射到其他磁盘或者其他目录上，甚至可以使用服务器端程序来回答对这个目录中的所有请求。服务器甚至可以完全不映射请求到一个目录结构，而可以使用一些其他的方案。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;HTTP版本&lt;/h3&gt;
&lt;p&gt;到目前为止，有三个版本的HTTP。第一个是HTTP/0.9，这是最原始，从来没有真正成为任何标准的规定。而HTTP/1.0，它已作为在RFC1945标准发布。HTTP/1.0是HTTP版本是今天普遍使用（通常与一些1.1的扩展），而HTTP/0.9基本没有被浏览器使用。&lt;/p&gt;
&lt;p&gt;RFC 2068描述了HTTP/1.1，它延伸并在若干方面改进HTTP/1.0 ，和1.0的主要区别是默认采用持久连接，让客户端请求的连接打开后进行保持，使其不必重新建立下一个请求,如果几次请求必须迅速发出，这样可以节省一些等待时间和服务器负载。&lt;/p&gt;
&lt;p&gt;HTTP/1.1相较于HTTP/1.0协议的区别主要体现在：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 缓存处理
- 带宽优化及网络连接的使用
- 错误通知的管理
- 消息在网络中的发送
- 互联网地址的维护
- 安全性及完整性
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;客户端发送请求&lt;/h3&gt;
&lt;p&gt;基本上，所有的请求看起来像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[METH] [REQUEST-URI] HTTP/[VER]
[fieldname1]: [field-value1]
[fieldname2]: [field-value2]

[request body, if any]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;METH（用于请求方法）给出了请求使用的方法，这里有几种请求方法，并且都做不同的事情。在上述的例子中使用的GET，但下面还有一些说明。REQUEST-URI是文档的服务器上的标识，如/index.html或什么的。VER是HTTP版本，就像在上面介绍的服务器的响应头中，下面的header和之前说服务器响应中一样的&lt;/p&gt;
&lt;p&gt;请求体仅用于将数据传输到服务器的请求，比如POST和PUT。&lt;/p&gt;

&lt;h4 id=&quot;get&quot;&gt;GET：取得一个文档&lt;/h4&gt;
&lt;p&gt;有几个请求的类型，最常见的一种是GET。GET请求基本意思是“给我这个文件”，看起来像这样：GET document_path HTTP/VER。对于URL http://www.yahoo.com/ 的document_path将是/，对于 http://www.w3.org/Talks/General.html 它是/Talks/General.html。&lt;/p&gt;
&lt;p&gt;不过，这第一行通常不是一个客户端（UA）唯一发送的请求，但它是唯一要紧的，必不可少的。UA可以包括多个报头字段(header field)的请求给服务器发送信息。这些字段的格式为fieldname: value，并都放在第一个请求行之后单独的行中。&lt;/p&gt;
&lt;p&gt;一些GET可以使用的报头字段是：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- User-Agent 标识用户代理
- Referer 告诉服务器用户从哪里来
- If-Modified-Since 主要用来检查cache是否过期
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;把所有这些碎片拼凑起来：下面是一个典型的GET请求，由我的浏览器（Opera）的发放：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET / HTTP/1.0
User-Agent: Mozilla/3.0 (compatible; Opera/3.0; Windows 95/NT4)
Accept: */*
Host: birk105.studby.uio.no:81
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;head&quot;&gt;HEAD：检查文件&lt;/h4&gt;

&lt;p&gt;有人有时候可能要查看特定文件由服务器返回的头，而无需实际下载的文件。这正是HEAD请求方法提供。HEAD工作原理和GET完全一样，区别只在于服务器只返回头而不是文件内容。&lt;/p&gt;
&lt;p&gt;这对像连接检查器这样的程序来说来说就很有用，他们只需要服务器返回的响应头和不需要文件内容。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;由服务器返回的响应&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;概要&lt;/h4&gt;

&lt;p&gt;服务器返回的响应包括含状态码的一行，报头字段的列表，一个空行，然后是请求的文档(如果有的话)。有点像这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; HTTP/1.0 code text
 Field1: Value1
 Field2: Value2

 ...Document content here...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;状态代码&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1XX：仅表示信息，没有1XX状态代码的定义，它们只保留给实验目的。&lt;/li&gt;
  &lt;li&gt;2XX：成功 其他的2xx状态码的其余部分主要是供脚本处理和不经常使用。
    &lt;ul&gt;
      &lt;li&gt;“200” ; 服务端成功接收并处理了客户端的请求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3XX：重定向(关于重定向我之后会专门写一篇文章来介绍
    &lt;ul&gt;
      &lt;li&gt;“301” ; 客户端所请求的URL已经移走，需要客户端重定向到其它的URL；&lt;/li&gt;
      &lt;li&gt;“304” ; 客户端所请求的URL未发生变化；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4XX：客户端错误
    &lt;ul&gt;
      &lt;li&gt;“400” ; 客户端请求错误；&lt;/li&gt;
      &lt;li&gt;“403” ; 客户端请求被服务端所禁止；&lt;/li&gt;
      &lt;li&gt;“404” ; 客户端所请求的URL在服务端不存在；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5XX：服务器错误
    &lt;ul&gt;
      &lt;li&gt;“500” ; 服务端在处理客户端请求时出现异常；&lt;/li&gt;
      &lt;li&gt;“502” ; 此为中间代理返回给客户端的出错信息，表明服务端返回给代理时出错；&lt;/li&gt;
      &lt;li&gt;“503” ; 服务端由于负载过高或其它错误而无法正常响应客户端请求；&lt;/li&gt;
      &lt;li&gt;“504” ; 此为中间代理返回给客户端的出错信息，表明代理连接服务端出现超时。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;响应头字段&lt;/h4&gt;
&lt;p&gt;下面列出了一些常用的字段，更多的请参考相关文档&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- Location
- Server
- Content-length
- Content-type
- Content-encoding
- Expires
- Last-modified
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;缓存：服务器和客户端之间的代理&lt;/h3&gt;

&lt;h4 id=&quot;the-browser-cache&quot;&gt;浏览器缓存The browser cache&lt;/h4&gt;
&lt;p&gt;你可能已经注意到，当你点击你不太久之前浏览过的页面时候，打开速度比之前更快很多。这是因为浏览器第一次下载这个页面时就在本地存储了一个副本。这个被保存的本地副本就称之为缓存。通常浏览器会设置有浏览器缓存的最大尺寸和文件的最大缓存时间。&lt;/p&gt;
&lt;p&gt;这意味着，当一个新的网页被浏览器访问、并存储在缓存中的时候，如果缓存满了（接近最大限制），浏览器就会删除它认为近期不太可能被再次被访问的一些文件，腾出缓存空间。此外，如果你去访问存储在缓存中的网页，浏览器可能会发现，这个页面设置的最大缓存时间是7天，而从上次访问到现在已经过去了8天，所以这个网页需要重新从服务器加载，即使缓存中有它的副本。&lt;/p&gt;
&lt;p&gt;究竟缓存是如何工作的，浏览器之间有些差异，但是上面是基本的想法，而且也是一个很好的想法，因为它不仅为用户节省了时间，也减少了网络流量。浏览器的缓存涉及到一些HTTP细节，将稍后介绍。&lt;/p&gt;

&lt;h4 id=&quot;proxy-caches&quot;&gt;代理缓存Proxy caches&lt;/h4&gt;

&lt;p&gt;浏览器缓存是一个不错的功能，但是当很多用户访问同一个网站，就会有很多浏览器从这个网站不断的下载更新缓存，显然这不是最优的方法。&lt;/p&gt;
&lt;p&gt;解决的办法是让用户共享缓存，这正是代理缓存做的事情。浏览器还是有它自己的缓存，只不过不在浏览器缓存里的文件的HTTP请求并不是直接发送到服务器了，而是发送到代理缓存。如果代理缓存里面存储了这个文件，它会直接返回给浏览器，如果没有代理缓存会把这个请求转发到服务器请求下载这个文件到代理缓存中然后返回给浏览器。&lt;/p&gt;
&lt;p&gt;所以，代理缓存就是很多用户共享的一个共同的缓存，可以显著的减少网络流量压力。但是代理缓存会扭曲基于日志的分析。&lt;/p&gt;
&lt;p&gt;一个更好的解决办法就是用一个层级架构的代理缓存系统，而不仅仅只使用单独的一个代理缓存。想象一下，一个大型的ISP为国家的每个区域设立一个代理缓存，让这些区域级的代理缓存共享一个国家级的代理缓存，而不是直接访问源服务器；这种解决方案可以更进一步的减少网络流量。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;服务器端编程&lt;/h3&gt;

&lt;h4 id=&quot;section-12&quot;&gt;服务器端编程是什么以及干什么&lt;/h4&gt;
&lt;p&gt;服务器端的脚本或程序就是运行在Web服务器上，响应来自客户端请求的程序。这些脚本产生正常的HTML（有时也可以是HTTP头）作为输出，然后反馈给客户端，就好像客户端是请求一个普通页面一样。其实，没有办法让客户端软件判断服务器是否使用了脚本程序。&lt;/p&gt;
&lt;p&gt;如JavaScript、VBSctrip和Java Applet等运行于客户端的技术，并不是服务器端脚本的例子。服务器端的脚本和客户端脚本的很大区别是客户端程序和服务器程序运行在不同的机器上，所以，如果一个程序处理的数据全都位于服务器机器上，那么它就应该是服务器端的脚本而不是客户端脚本。如果程序需要经常和用户进行交互，那么使用基于客户端的技术更好，这样可以减少向服务器发送请求。&lt;/p&gt;
&lt;p&gt;所以，一般情况下，需要大量数据处理和很少交换的程序应该基于服务器开发；而处理少量数据和频繁交互的程序应该放在客户端。&lt;/p&gt;
&lt;p&gt;还有一种情况经常被遗漏的就是，如果你需要一个程序处理数据也需要很多用户交互该如何做？近在眼前的有一种叫XML的技术，这里就不做深入了。&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;它是如何工作的&lt;/h4&gt;

&lt;p&gt;根据使用的技术的不同，服务器端脚本的具体细节和工作原理有很大不同，而且有很多技术可以使用。但是，有些东西是不变的：服务器收到一个请求，但是需要注意的是，请求的URL并不对应于一个通常的文件，而是映射到一个脚本程序。&lt;/p&gt;
&lt;p&gt;然后服务器启动这个脚本程序，把请求头提供信息和URL全部传给脚本程序，脚本程序运行并产生HTML文档和HTTP响应头，然后服务器把它返回给客户端。&lt;/p&gt;

&lt;h4 id=&quot;cgi&quot;&gt;CGI&lt;/h4&gt;

&lt;p&gt;通用网关接口(CGI,Common Gateway Interface)是一种Web服务器和服务器端编程进行交互的方式。CGI完全独立于编程语言，操作系统和Web服务器。目前，它是最常见的服务器端编程技术，几乎每一个Web服务器都支持。此外，所有服务器用几乎同样的方式实现它，这样你可以为一个服务器编写CGI脚本，然后分发到任何Web服务器上运行。&lt;/p&gt;
&lt;p&gt;就像上面说的，服务器需要一种方法来知道哪些URL映射到脚本而其中另一些URL只映射到普通的HTML文件。对于CGI通常是通过在服务器上创建CGI目录。具体做是在服务器进行设置，并告诉服务器，当请求一个特定的顶层目录下的文件时就执行这些CGI脚本（位于磁盘上的某个地方）。（缺省目录通常是/ cgi-bin/，所以一看就知道，像这样的URL：http://www.varsity.edu/cgi-bin/search指向一个CGI脚本，需要注意的是可以任意设定该目录。）有些服务器也可以设置为不使用CGI目录，而要求所有的CGI程序都用已.cgi结尾的文件名。&lt;/p&gt;
&lt;p&gt;CGI程序只是普通的可执行程序（或解释性程序，比如Perl或Python，只要服务器知道如何启动程序），因此你可以使用几乎任何你想要的编程语言。在CGI程序被Web服务器启动之前，web服务器定义了一些包含从请求中接收到的信息的变量。这方面的例子有客户端的IP地址，请求头等，如果请求的URL中包含一个问号(?),那么问号之后的一切都会设置成变量。&lt;/p&gt;
&lt;p&gt;这意味着，关于请求的额外信息可以被放入该URL的链接。这是像点击计数器用来判断是哪些项目被点击的常用方法之一。因此，用户可以在他/她的页面插入一个图像，并具有SRC属性是一个链接到这样的CGI脚本：SRC =http://stats.vendor.com/cgi-bin/counter.pl?username 。那么脚本就可以知道哪些用户被击中，增量和显示正确的计数。&lt;/p&gt;
&lt;p&gt;CGI输出其返回（HTTP头和HTML文档）到服务器的方式是非常简单的：它把它写到标准输出。换句话说，在一个Perl或Python的脚本中，你只需要使用print语句。在C语言中使用printf或者一些等效的函数（C++使用cout«），而Java将使用System.out.println。&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;其他技术&lt;/h4&gt;

&lt;p&gt;CGI不是进行服务器端编程的唯一途径，且一直为人诟病低效率。有时候确实是那样，因为每次请求CGI程序就会重新被加载到内存然后执行。一个更快的替代方案是直接使用服务器API本身进行编程，即让程序成为服务器进程的一部分，直接利用提供的API来完成工作，这样当然是服务器相关的，而且如果使用像c/c++（通常都是）导致的程序错误可能使整个服务器崩溃。&lt;/p&gt;
&lt;p&gt;基于服务器API编程的主要优点在于，当请求到达时，程序和需要的数据已经在内存中，这样确实会快很多。&lt;/p&gt;
&lt;p&gt;有些服务器允许不会导致崩溃的脚本语言。一个例子是AOLserver的，它采用TCL。也有可用的服务器，比如Apache，它让你可以使用Perl或Python进行服务器的API编程，有效地消除了因编程错误引起服务器崩溃的风险。&lt;/p&gt;
&lt;p&gt;也有很多很多专利的（和非专有）脚本语言和技术，以及各种web服务器。一些最有名的是ASP，MetaHTML和PHP3。&lt;/p&gt;

</description>
        <pubDate>Wed, 28 Dec 2016 12:22:38 +0800</pubDate>
        <link>http://yourdomain.com/computer_basis_knowledge/2016/12/28/article1.html</link>
        <guid isPermaLink="true">http://yourdomain.com/computer_basis_knowledge/2016/12/28/article1.html</guid>
        
        
        <category>computer_basis_knowledge</category>
        
      </item>
    
  </channel>
</rss>
